// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: proto/user/v1/user.proto

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UserService_GetUserById_FullMethodName = "/user.UserService/GetUserById"
	UserService_CreateUser_FullMethodName  = "/user.UserService/CreateUser"
	UserService_UpdateUser_FullMethodName  = "/user.UserService/UpdateUser"
	UserService_DeleteUser_FullMethodName  = "/user.UserService/DeleteUser"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ==================== 用户服务 ====================
type UserServiceClient interface {
	GetUserById(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*UserResponse, error)
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*UserResponse, error)
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UserResponse, error)
	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) GetUserById(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, UserService_GetUserById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, UserService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
//
// ==================== 用户服务 ====================
type UserServiceServer interface {
	GetUserById(context.Context, *GetUserRequest) (*UserResponse, error)
	CreateUser(context.Context, *CreateUserRequest) (*UserResponse, error)
	UpdateUser(context.Context, *UpdateUserRequest) (*UserResponse, error)
	DeleteUser(context.Context, *DeleteUserRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) GetUserById(context.Context, *GetUserRequest) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserById not implemented")
}
func (UnimplementedUserServiceServer) CreateUser(context.Context, *CreateUserRequest) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *DeleteUserRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_GetUserById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserById(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*DeleteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserById",
			Handler:    _UserService_GetUserById_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/user/v1/user.proto",
}

const (
	MerchantService_GetMerchantById_FullMethodName = "/user.MerchantService/GetMerchantById"
	MerchantService_CreateMerchant_FullMethodName  = "/user.MerchantService/CreateMerchant"
	MerchantService_UpdateMerchant_FullMethodName  = "/user.MerchantService/UpdateMerchant"
	MerchantService_DeleteMerchant_FullMethodName  = "/user.MerchantService/DeleteMerchant"
)

// MerchantServiceClient is the client API for MerchantService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ==================== 商户服务 ====================
type MerchantServiceClient interface {
	GetMerchantById(ctx context.Context, in *GetMerchantRequest, opts ...grpc.CallOption) (*MerchantResponse, error)
	CreateMerchant(ctx context.Context, in *CreateMerchantRequest, opts ...grpc.CallOption) (*MerchantResponse, error)
	UpdateMerchant(ctx context.Context, in *UpdateMerchantRequest, opts ...grpc.CallOption) (*MerchantResponse, error)
	DeleteMerchant(ctx context.Context, in *DeleteMerchantRequest, opts ...grpc.CallOption) (*DeleteMerchantResponse, error)
}

type merchantServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMerchantServiceClient(cc grpc.ClientConnInterface) MerchantServiceClient {
	return &merchantServiceClient{cc}
}

func (c *merchantServiceClient) GetMerchantById(ctx context.Context, in *GetMerchantRequest, opts ...grpc.CallOption) (*MerchantResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MerchantResponse)
	err := c.cc.Invoke(ctx, MerchantService_GetMerchantById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *merchantServiceClient) CreateMerchant(ctx context.Context, in *CreateMerchantRequest, opts ...grpc.CallOption) (*MerchantResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MerchantResponse)
	err := c.cc.Invoke(ctx, MerchantService_CreateMerchant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *merchantServiceClient) UpdateMerchant(ctx context.Context, in *UpdateMerchantRequest, opts ...grpc.CallOption) (*MerchantResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MerchantResponse)
	err := c.cc.Invoke(ctx, MerchantService_UpdateMerchant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *merchantServiceClient) DeleteMerchant(ctx context.Context, in *DeleteMerchantRequest, opts ...grpc.CallOption) (*DeleteMerchantResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMerchantResponse)
	err := c.cc.Invoke(ctx, MerchantService_DeleteMerchant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MerchantServiceServer is the server API for MerchantService service.
// All implementations must embed UnimplementedMerchantServiceServer
// for forward compatibility.
//
// ==================== 商户服务 ====================
type MerchantServiceServer interface {
	GetMerchantById(context.Context, *GetMerchantRequest) (*MerchantResponse, error)
	CreateMerchant(context.Context, *CreateMerchantRequest) (*MerchantResponse, error)
	UpdateMerchant(context.Context, *UpdateMerchantRequest) (*MerchantResponse, error)
	DeleteMerchant(context.Context, *DeleteMerchantRequest) (*DeleteMerchantResponse, error)
	mustEmbedUnimplementedMerchantServiceServer()
}

// UnimplementedMerchantServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMerchantServiceServer struct{}

func (UnimplementedMerchantServiceServer) GetMerchantById(context.Context, *GetMerchantRequest) (*MerchantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMerchantById not implemented")
}
func (UnimplementedMerchantServiceServer) CreateMerchant(context.Context, *CreateMerchantRequest) (*MerchantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMerchant not implemented")
}
func (UnimplementedMerchantServiceServer) UpdateMerchant(context.Context, *UpdateMerchantRequest) (*MerchantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMerchant not implemented")
}
func (UnimplementedMerchantServiceServer) DeleteMerchant(context.Context, *DeleteMerchantRequest) (*DeleteMerchantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMerchant not implemented")
}
func (UnimplementedMerchantServiceServer) mustEmbedUnimplementedMerchantServiceServer() {}
func (UnimplementedMerchantServiceServer) testEmbeddedByValue()                         {}

// UnsafeMerchantServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MerchantServiceServer will
// result in compilation errors.
type UnsafeMerchantServiceServer interface {
	mustEmbedUnimplementedMerchantServiceServer()
}

func RegisterMerchantServiceServer(s grpc.ServiceRegistrar, srv MerchantServiceServer) {
	// If the following call pancis, it indicates UnimplementedMerchantServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MerchantService_ServiceDesc, srv)
}

func _MerchantService_GetMerchantById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMerchantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).GetMerchantById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MerchantService_GetMerchantById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).GetMerchantById(ctx, req.(*GetMerchantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MerchantService_CreateMerchant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMerchantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).CreateMerchant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MerchantService_CreateMerchant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).CreateMerchant(ctx, req.(*CreateMerchantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MerchantService_UpdateMerchant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMerchantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).UpdateMerchant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MerchantService_UpdateMerchant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).UpdateMerchant(ctx, req.(*UpdateMerchantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MerchantService_DeleteMerchant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMerchantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MerchantServiceServer).DeleteMerchant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MerchantService_DeleteMerchant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MerchantServiceServer).DeleteMerchant(ctx, req.(*DeleteMerchantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MerchantService_ServiceDesc is the grpc.ServiceDesc for MerchantService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MerchantService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.MerchantService",
	HandlerType: (*MerchantServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMerchantById",
			Handler:    _MerchantService_GetMerchantById_Handler,
		},
		{
			MethodName: "CreateMerchant",
			Handler:    _MerchantService_CreateMerchant_Handler,
		},
		{
			MethodName: "UpdateMerchant",
			Handler:    _MerchantService_UpdateMerchant_Handler,
		},
		{
			MethodName: "DeleteMerchant",
			Handler:    _MerchantService_DeleteMerchant_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/user/v1/user.proto",
}

const (
	AddressService_GetUserAddresses_FullMethodName  = "/user.AddressService/GetUserAddresses"
	AddressService_CreateUserAddress_FullMethodName = "/user.AddressService/CreateUserAddress"
	AddressService_UpdateUserAddress_FullMethodName = "/user.AddressService/UpdateUserAddress"
	AddressService_DeleteUserAddress_FullMethodName = "/user.AddressService/DeleteUserAddress"
)

// AddressServiceClient is the client API for AddressService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ==================== 用户地址服务 ====================
type AddressServiceClient interface {
	GetUserAddresses(ctx context.Context, in *GetUserAddressRequest, opts ...grpc.CallOption) (*UserAddressListResponse, error)
	CreateUserAddress(ctx context.Context, in *CreateUserAddressRequest, opts ...grpc.CallOption) (*UserAddressResponse, error)
	UpdateUserAddress(ctx context.Context, in *UpdateUserAddressRequest, opts ...grpc.CallOption) (*UserAddressResponse, error)
	DeleteUserAddress(ctx context.Context, in *DeleteUserAddressRequest, opts ...grpc.CallOption) (*DeleteUserAddressResponse, error)
}

type addressServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAddressServiceClient(cc grpc.ClientConnInterface) AddressServiceClient {
	return &addressServiceClient{cc}
}

func (c *addressServiceClient) GetUserAddresses(ctx context.Context, in *GetUserAddressRequest, opts ...grpc.CallOption) (*UserAddressListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserAddressListResponse)
	err := c.cc.Invoke(ctx, AddressService_GetUserAddresses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressServiceClient) CreateUserAddress(ctx context.Context, in *CreateUserAddressRequest, opts ...grpc.CallOption) (*UserAddressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserAddressResponse)
	err := c.cc.Invoke(ctx, AddressService_CreateUserAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressServiceClient) UpdateUserAddress(ctx context.Context, in *UpdateUserAddressRequest, opts ...grpc.CallOption) (*UserAddressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserAddressResponse)
	err := c.cc.Invoke(ctx, AddressService_UpdateUserAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressServiceClient) DeleteUserAddress(ctx context.Context, in *DeleteUserAddressRequest, opts ...grpc.CallOption) (*DeleteUserAddressResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserAddressResponse)
	err := c.cc.Invoke(ctx, AddressService_DeleteUserAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AddressServiceServer is the server API for AddressService service.
// All implementations must embed UnimplementedAddressServiceServer
// for forward compatibility.
//
// ==================== 用户地址服务 ====================
type AddressServiceServer interface {
	GetUserAddresses(context.Context, *GetUserAddressRequest) (*UserAddressListResponse, error)
	CreateUserAddress(context.Context, *CreateUserAddressRequest) (*UserAddressResponse, error)
	UpdateUserAddress(context.Context, *UpdateUserAddressRequest) (*UserAddressResponse, error)
	DeleteUserAddress(context.Context, *DeleteUserAddressRequest) (*DeleteUserAddressResponse, error)
	mustEmbedUnimplementedAddressServiceServer()
}

// UnimplementedAddressServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAddressServiceServer struct{}

func (UnimplementedAddressServiceServer) GetUserAddresses(context.Context, *GetUserAddressRequest) (*UserAddressListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserAddresses not implemented")
}
func (UnimplementedAddressServiceServer) CreateUserAddress(context.Context, *CreateUserAddressRequest) (*UserAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUserAddress not implemented")
}
func (UnimplementedAddressServiceServer) UpdateUserAddress(context.Context, *UpdateUserAddressRequest) (*UserAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserAddress not implemented")
}
func (UnimplementedAddressServiceServer) DeleteUserAddress(context.Context, *DeleteUserAddressRequest) (*DeleteUserAddressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserAddress not implemented")
}
func (UnimplementedAddressServiceServer) mustEmbedUnimplementedAddressServiceServer() {}
func (UnimplementedAddressServiceServer) testEmbeddedByValue()                        {}

// UnsafeAddressServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AddressServiceServer will
// result in compilation errors.
type UnsafeAddressServiceServer interface {
	mustEmbedUnimplementedAddressServiceServer()
}

func RegisterAddressServiceServer(s grpc.ServiceRegistrar, srv AddressServiceServer) {
	// If the following call pancis, it indicates UnimplementedAddressServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AddressService_ServiceDesc, srv)
}

func _AddressService_GetUserAddresses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServiceServer).GetUserAddresses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AddressService_GetUserAddresses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServiceServer).GetUserAddresses(ctx, req.(*GetUserAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AddressService_CreateUserAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServiceServer).CreateUserAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AddressService_CreateUserAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServiceServer).CreateUserAddress(ctx, req.(*CreateUserAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AddressService_UpdateUserAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServiceServer).UpdateUserAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AddressService_UpdateUserAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServiceServer).UpdateUserAddress(ctx, req.(*UpdateUserAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AddressService_DeleteUserAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressServiceServer).DeleteUserAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AddressService_DeleteUserAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressServiceServer).DeleteUserAddress(ctx, req.(*DeleteUserAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AddressService_ServiceDesc is the grpc.ServiceDesc for AddressService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AddressService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.AddressService",
	HandlerType: (*AddressServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserAddresses",
			Handler:    _AddressService_GetUserAddresses_Handler,
		},
		{
			MethodName: "CreateUserAddress",
			Handler:    _AddressService_CreateUserAddress_Handler,
		},
		{
			MethodName: "UpdateUserAddress",
			Handler:    _AddressService_UpdateUserAddress_Handler,
		},
		{
			MethodName: "DeleteUserAddress",
			Handler:    _AddressService_DeleteUserAddress_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/user/v1/user.proto",
}

const (
	PointService_GetUserPoints_FullMethodName    = "/user.PointService/GetUserPoints"
	PointService_AddUserPoints_FullMethodName    = "/user.PointService/AddUserPoints"
	PointService_DeductUserPoints_FullMethodName = "/user.PointService/DeductUserPoints"
)

// PointServiceClient is the client API for PointService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ==================== 用户积分服务 ====================
type PointServiceClient interface {
	GetUserPoints(ctx context.Context, in *GetUserPointsRequest, opts ...grpc.CallOption) (*UserPointsResponse, error)
	AddUserPoints(ctx context.Context, in *AddUserPointsRequest, opts ...grpc.CallOption) (*UserPointResponse, error)
	DeductUserPoints(ctx context.Context, in *DeductUserPointsRequest, opts ...grpc.CallOption) (*UserPointResponse, error)
}

type pointServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPointServiceClient(cc grpc.ClientConnInterface) PointServiceClient {
	return &pointServiceClient{cc}
}

func (c *pointServiceClient) GetUserPoints(ctx context.Context, in *GetUserPointsRequest, opts ...grpc.CallOption) (*UserPointsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserPointsResponse)
	err := c.cc.Invoke(ctx, PointService_GetUserPoints_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointServiceClient) AddUserPoints(ctx context.Context, in *AddUserPointsRequest, opts ...grpc.CallOption) (*UserPointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserPointResponse)
	err := c.cc.Invoke(ctx, PointService_AddUserPoints_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pointServiceClient) DeductUserPoints(ctx context.Context, in *DeductUserPointsRequest, opts ...grpc.CallOption) (*UserPointResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserPointResponse)
	err := c.cc.Invoke(ctx, PointService_DeductUserPoints_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PointServiceServer is the server API for PointService service.
// All implementations must embed UnimplementedPointServiceServer
// for forward compatibility.
//
// ==================== 用户积分服务 ====================
type PointServiceServer interface {
	GetUserPoints(context.Context, *GetUserPointsRequest) (*UserPointsResponse, error)
	AddUserPoints(context.Context, *AddUserPointsRequest) (*UserPointResponse, error)
	DeductUserPoints(context.Context, *DeductUserPointsRequest) (*UserPointResponse, error)
	mustEmbedUnimplementedPointServiceServer()
}

// UnimplementedPointServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPointServiceServer struct{}

func (UnimplementedPointServiceServer) GetUserPoints(context.Context, *GetUserPointsRequest) (*UserPointsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserPoints not implemented")
}
func (UnimplementedPointServiceServer) AddUserPoints(context.Context, *AddUserPointsRequest) (*UserPointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserPoints not implemented")
}
func (UnimplementedPointServiceServer) DeductUserPoints(context.Context, *DeductUserPointsRequest) (*UserPointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeductUserPoints not implemented")
}
func (UnimplementedPointServiceServer) mustEmbedUnimplementedPointServiceServer() {}
func (UnimplementedPointServiceServer) testEmbeddedByValue()                      {}

// UnsafePointServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PointServiceServer will
// result in compilation errors.
type UnsafePointServiceServer interface {
	mustEmbedUnimplementedPointServiceServer()
}

func RegisterPointServiceServer(s grpc.ServiceRegistrar, srv PointServiceServer) {
	// If the following call pancis, it indicates UnimplementedPointServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PointService_ServiceDesc, srv)
}

func _PointService_GetUserPoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserPointsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointServiceServer).GetUserPoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PointService_GetUserPoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointServiceServer).GetUserPoints(ctx, req.(*GetUserPointsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PointService_AddUserPoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserPointsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointServiceServer).AddUserPoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PointService_AddUserPoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointServiceServer).AddUserPoints(ctx, req.(*AddUserPointsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PointService_DeductUserPoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeductUserPointsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PointServiceServer).DeductUserPoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PointService_DeductUserPoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PointServiceServer).DeductUserPoints(ctx, req.(*DeductUserPointsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PointService_ServiceDesc is the grpc.ServiceDesc for PointService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PointService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.PointService",
	HandlerType: (*PointServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserPoints",
			Handler:    _PointService_GetUserPoints_Handler,
		},
		{
			MethodName: "AddUserPoints",
			Handler:    _PointService_AddUserPoints_Handler,
		},
		{
			MethodName: "DeductUserPoints",
			Handler:    _PointService_DeductUserPoints_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/user/v1/user.proto",
}

const (
	TagService_GetUserTags_FullMethodName   = "/user.TagService/GetUserTags"
	TagService_AddUserTag_FullMethodName    = "/user.TagService/AddUserTag"
	TagService_RemoveUserTag_FullMethodName = "/user.TagService/RemoveUserTag"
)

// TagServiceClient is the client API for TagService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ==================== 用户标签服务 ====================
type TagServiceClient interface {
	GetUserTags(ctx context.Context, in *GetUserTagsRequest, opts ...grpc.CallOption) (*UserTagListResponse, error)
	AddUserTag(ctx context.Context, in *AddUserTagRequest, opts ...grpc.CallOption) (*UserTagResponse, error)
	RemoveUserTag(ctx context.Context, in *RemoveUserTagRequest, opts ...grpc.CallOption) (*UserTagResponse, error)
}

type tagServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTagServiceClient(cc grpc.ClientConnInterface) TagServiceClient {
	return &tagServiceClient{cc}
}

func (c *tagServiceClient) GetUserTags(ctx context.Context, in *GetUserTagsRequest, opts ...grpc.CallOption) (*UserTagListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserTagListResponse)
	err := c.cc.Invoke(ctx, TagService_GetUserTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) AddUserTag(ctx context.Context, in *AddUserTagRequest, opts ...grpc.CallOption) (*UserTagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserTagResponse)
	err := c.cc.Invoke(ctx, TagService_AddUserTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tagServiceClient) RemoveUserTag(ctx context.Context, in *RemoveUserTagRequest, opts ...grpc.CallOption) (*UserTagResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserTagResponse)
	err := c.cc.Invoke(ctx, TagService_RemoveUserTag_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TagServiceServer is the server API for TagService service.
// All implementations must embed UnimplementedTagServiceServer
// for forward compatibility.
//
// ==================== 用户标签服务 ====================
type TagServiceServer interface {
	GetUserTags(context.Context, *GetUserTagsRequest) (*UserTagListResponse, error)
	AddUserTag(context.Context, *AddUserTagRequest) (*UserTagResponse, error)
	RemoveUserTag(context.Context, *RemoveUserTagRequest) (*UserTagResponse, error)
	mustEmbedUnimplementedTagServiceServer()
}

// UnimplementedTagServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTagServiceServer struct{}

func (UnimplementedTagServiceServer) GetUserTags(context.Context, *GetUserTagsRequest) (*UserTagListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserTags not implemented")
}
func (UnimplementedTagServiceServer) AddUserTag(context.Context, *AddUserTagRequest) (*UserTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddUserTag not implemented")
}
func (UnimplementedTagServiceServer) RemoveUserTag(context.Context, *RemoveUserTagRequest) (*UserTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUserTag not implemented")
}
func (UnimplementedTagServiceServer) mustEmbedUnimplementedTagServiceServer() {}
func (UnimplementedTagServiceServer) testEmbeddedByValue()                    {}

// UnsafeTagServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TagServiceServer will
// result in compilation errors.
type UnsafeTagServiceServer interface {
	mustEmbedUnimplementedTagServiceServer()
}

func RegisterTagServiceServer(s grpc.ServiceRegistrar, srv TagServiceServer) {
	// If the following call pancis, it indicates UnimplementedTagServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TagService_ServiceDesc, srv)
}

func _TagService_GetUserTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).GetUserTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_GetUserTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).GetUserTags(ctx, req.(*GetUserTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_AddUserTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddUserTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).AddUserTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_AddUserTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).AddUserTag(ctx, req.(*AddUserTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TagService_RemoveUserTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveUserTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TagServiceServer).RemoveUserTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TagService_RemoveUserTag_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TagServiceServer).RemoveUserTag(ctx, req.(*RemoveUserTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TagService_ServiceDesc is the grpc.ServiceDesc for TagService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TagService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "user.TagService",
	HandlerType: (*TagServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserTags",
			Handler:    _TagService_GetUserTags_Handler,
		},
		{
			MethodName: "AddUserTag",
			Handler:    _TagService_AddUserTag_Handler,
		},
		{
			MethodName: "RemoveUserTag",
			Handler:    _TagService_RemoveUserTag_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/user/v1/user.proto",
}
